THUAT TOAN: Phan tich Cholesky co dien (Classical Cholesky)
DO PHUC TAP: O(n^3)

PSEUDO CODE:
function classicalCholesky(A):
    n = size(A)
    L = matrix(n, n) filled with 0
    
    for i = 0 to n-1:
        for j = 0 to i:
            sum = 0
            for k = 0 to j-1:
                sum = sum + L[i][k] * L[j][k]
            
            if i == j:
                L[i][j] = sqrt(A[i][i] - sum)
            else:
                L[i][j] = (A[i][j] - sum) / L[j][j]
    
    return L


THUAT TOAN: Phan tich Cholesky bien the (LDL^T)
DO PHUC TAP: O(n^3)

PSEUDO CODE:
function variantCholesky(A):
    n = size(A)
    L = identity_matrix(n, n)
    D = matrix(n, n) filled with 0
    
    for i = 0 to n-1:
        for j = 0 to i:
            sum = 0
            for k = 0 to j-1:
                sum = sum + L[i][k] * D[k][k] * L[j][k]
            
            if i == j:
                D[i][i] = A[i][i] - sum
            else:
                L[i][j] = (A[i][j] - sum) / D[j][j]
    
    return (L, D)


THUAT TOAN: Phan tich gia tri rieng (Jacobi Eigenvalue Algorithm)
DO PHUC TAP: O(n^3 * iterations)

PSEUDO CODE:
function jacobiEigenvalue(A):
    n = size(A)
    B = copy(A)
    V = identity_matrix(n, n)
    
    maxIter = 100
    epsilon = 1e-10
    
    for iter = 0 to maxIter:
        // Tim phan tu off-diagonal lon nhat
        maxVal = 0
        p = 0
        q = 1
        for i = 0 to n-1:
            for j = i+1 to n-1:
                if |B[i][j]| > maxVal:
                    maxVal = |B[i][j]|
                    p = i
                    q = j
        
        if maxVal < epsilon:
            break
        
        // Tinh goc xoay theta
        theta = 0.5 * atan2(2 * B[p][q], B[p][p] - B[q][q])
        c = cos(theta)
        s = sin(theta)
        
        // Cap nhat ma tran B (Givens rotation)
        for i = 0 to n-1:
            Bip = B[i][p]
            Biq = B[i][q]
            B[i][p] = c * Bip + s * Biq
            B[i][q] = -s * Bip + c * Biq
            B[p][i] = B[i][p]
            B[q][i] = B[i][q]
        
        Bpp = B[p][p]
        Bqq = B[q][q]
        Bpq = B[p][q]
        B[p][p] = c*c*Bpp + 2*c*s*Bpq + s*s*Bqq
        B[q][q] = s*s*Bpp - 2*c*s*Bpq + c*c*Bqq
        B[p][q] = B[q][p] = 0
        
        // Cap nhat eigenvectors
        for i = 0 to n-1:
            Vip = V[i][p]
            Viq = V[i][q]
            V[i][p] = c * Vip + s * Viq
            V[i][q] = -s * Vip + c * Viq
    
    // Gia tri rieng la cac phan tu duong cheo cua B
    eigenvalues = diagonal(B)
    eigenvectors = V
    
    return (eigenvalues, eigenvectors)

MÔ TẢ BẰNG NGÔN NGỮ TỰ NHIÊN:

Kết hợp Cholesky và tính trị riêng:

Phần 1: Phân tích Cholesky
- Input: Ma trận đối xứng xác định dương A
- Output: Ma trận tam giác dưới L sao cho A = L×Lᵀ
- Công thức:
  * L[i][i] = √(A[i][i] - Σⱼ₌₀^(i-1) L[i][j]²)
  * L[i][j] = (A[i][j] - Σₖ₌₀^(j-1) L[i][k]×L[j][k]) / L[j][j] (với i > j)
- Tính từ trái sang phải, từ trên xuống dưới

Phần 2: Tính trị riêng và vector riêng bằng phương pháp Jacobi
- Ý tưởng: Dùng chuỗi phép quay Givens để biến ma trận về dạng đường chéo
- Mỗi phép quay làm triệt tiêu một cặp phần tử đối xứng ngoài đường chéo

Thuật toán Jacobi:

Bước 1: Khởi tạo
- B = A (ma trận cần tính trị riêng)
- V = I (ma trận đơn vị, sẽ tích lũy các vector riêng)

Bước 2: Lặp cho đến khi hội tụ:
- Tìm phần tử lớn nhất ngoài đường chéo: B[p][q]
- Nếu |B[p][q]| < ngưỡng → dừng

Bước 3: Xây dựng ma trận quay Givens G(p,q,θ):
- Tính góc quay θ để triệt tiêu B[p][q]
- tan(2θ) = 2B[p][q] / (B[p][p] - B[q][q])
- Tính cos θ và sin θ

Bước 4: Áp dụng phép quay:
- B' = Gᵀ × B × G (cập nhật ma trận)
- V' = V × G (tích lũy vector riêng)
- Chỉ cần cập nhật hàng/cột p và q (hiệu quả)

Bước 5: Kết quả:
- Trị riêng = các phần tử trên đường chéo của B
- Vector riêng = các cột của ma trận V

Giải thích hình học:
- Mỗi phép quay Givens xoay hệ tọa độ một chút
- Dần dần, các trục tọa độ trùng với các vector riêng
- Giống như lắc một chiếc hộp chứa bột: các hạt sẽ sắp xếp theo các trục chính

Ưu điểm phương pháp Jacobi:
- Đơn giản, dễ hiểu
- Ổn định số, không bị mất chính xác
- Song song hóa tốt (nhiều cặp độc lập)
- Phù hợp ma trận đối xứng dày đặc

Nhược điểm:
- Chậm hơn QR cho ma trận lớn
- Số vòng lặp không xác định trước

Ứng dụng:
- Phân tích thành phần chính (PCA)
- Xử lý tín hiệu
- Phân tích dao động kết cấu
- Cơ học lượng tử
