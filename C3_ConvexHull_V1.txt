THUAT TOAN: Bao loi (Andrew's Monotone Chain - Convex Hull)
DO PHUC TAP: O(n * log(n))

PSEUDO CODE:
function andrewConvexHull(points):
    n = length(points)
    if n <= 1:
        return points
    
    sort(points)
    
    lower = []
    for i = 0 to n-1:
        while length(lower) >= 2 and 
              crossProduct(lower[length-2], lower[length-1], points[i]) <= 0:
            lower.pop()
        lower.append(points[i])
    
    upper = []
    for i = n-1 down to 0:
        while length(upper) >= 2 and 
              crossProduct(upper[length-2], upper[length-1], points[i]) <= 0:
            upper.pop()
        upper.append(points[i])
    
    lower.pop()
    upper.pop()
    
    hull = lower + upper
    return hull


THUAT TOAN: Tinh dien tich bao loi (Shoelace Formula)
DO PHUC TAP: O(n)

PSEUDO CODE:
function calculateArea(hull):
    n = length(hull)
    area = 0
    for i = 0 to n-1:
        j = (i + 1) % n
        area = area + hull[i].x * hull[j].y - hull[j].x * hull[i].y
    return |area| / 2


THUAT TOAN: Tim canh ngan nhat
DO PHUC TAP: O(n)

PSEUDO CODE:
function findShortestEdge(hull):
    minEdge = infinity
    for i = 0 to n-1:
        j = (i + 1) % n
        minEdge = min(minEdge, distance(hull[i], hull[j]))
    return minEdge


THUAT TOAN: Tim cap diem gan nhat (Closest Pair - Divide and Conquer)
DO PHUC TAP: O(n * log(n))

PSEUDO CODE:
function closestPair(px, py, n):
    if n <= 3:
        return bruteForce(px, n)
    
    mid = n / 2
    midPoint = px[mid]
    
    pyl = [p in py if p.x <= midPoint.x]
    pyr = [p in py if p.x > midPoint.x]
    
    dl = closestPair(px[0..mid], pyl, mid)
    dr = closestPair(px[mid..n], pyr, n-mid)
    
    d = min(dl, dr)
    
    strip = [p in py if |p.x - midPoint.x| < d]
    
    for i = 0 to length(strip)-1:
        j = i + 1
        while j < length(strip) and (strip[j].y - strip[i].y) < d:
            d = min(d, distance(strip[i], strip[j]))
            j = j + 1
    
    return d

MÔ TẢ BẰNG NGÔN NGỮ TỰ NHIÊN:

Thuật toán: Bao lồi Andrew's Monotone Chain

Input:
• Danh sách điểm points = [(x₁,y₁), (x₂,y₂), ..., (xₙ,yₙ)]

Khởi tạo:
• Sắp xếp points theo (x, y) tăng dần

Lặp:
1. Xây dựng nửa dưới (lower hull):
   - Với mỗi điểm p:
     * Trong khi có ≥ 2 điểm trong lower và rẽ phải:
       - Loại điểm cuối
     * Thêm p vào lower

2. Xây dựng nửa trên (upper hull):
   - Duyệt ngược từ cuối về đầu
   - Tương tự như nửa dưới

3. Kết hợp: hull = lower + upper

Kiểm tra rẽ: crossProduct(A, B, C)
• cross = (B.x - A.x)×(C.y - A.y) - (B.y - A.y)×(C.x - A.x)
• cross ≤ 0: rẽ phải (loại B)
• cross > 0: rẽ trái (giữ B)

---

Thuật toán: Diện tích (Shoelace Formula)

Input:
• Đa giác hull = [p₀, p₁, ..., pₙ₋₁]

Công thức:
• Area = ½ |Σᵢ₌₀ⁿ⁻¹ (xᵢ×yᵢ₊₁ - xᵢ₊₁×yᵢ)|

---

Thuật toán: Cặp điểm gần nhất (Divide & Conquer)

Input:
• Danh sách điểm đã sắp xếp theo x, y

Lặp:
1. Nếu n ≤ 3: brute force

2. Chia đôi:
   - dₗ = closestPair(nửa trái)
   - dᵣ = closestPair(nửa phải)
   - d = min(dₗ, dᵣ)

3. Kiểm tra strip (dải rộng 2d):
   - Chỉ kiểm tra điểm trong strip
   - Mỗi điểm so với 7 điểm kế
   - Cập nhật d nếu tìm được nhỏ hơn

4. Trả về d
