THUAT TOAN: Phan tich SVD (Singular Value Decomposition - Jacobi approach)
DO PHUC TAP: O(m*n^2 + n^3)

PSEUDO CODE:
function SVD(A):
    // A: ma tran m x n
    // Tra ve: U, Sigma, V sao cho A = U * Sigma * V^T
    
    m = rows(A)
    n = cols(A)
    
    // Buoc 1: Tinh A^T * A (n x n)
    ATA = transpose(A) * A
    
    // Buoc 2: Tim eigenvalues va eigenvectors cua A^T * A
    // Su dung Jacobi method
    V, D = jacobiEigenvalue(ATA)
    
    // Buoc 3: Tinh singular values tu eigenvalues
    singularValues = []
    for i = 0 to n-1:
        singularValues[i] = sqrt(D[i][i])
    
    // Buoc 4: Sap xep singular values giam dan
    sortDescending(singularValues, V)
    
    // Buoc 5: Tao ma tran Sigma (m x n)
    Sigma = matrix(m, n) filled with 0
    for i = 0 to min(m,n)-1:
        Sigma[i][i] = singularValues[i]
    
    // Buoc 6: Tinh U = A * V * Sigma^(-1)
    U = matrix(m, n)
    for i = 0 to m-1:
        for j = 0 to n-1:
            sum = 0
            for k = 0 to n-1:
                if singularValues[k] > epsilon:
                    sum = sum + A[i][k] * V[k][j] / singularValues[j]
            U[i][j] = sum
    
    return (U, Sigma, V)

MÔ TẢ BẰNG NGÔN NGỮ TỰ NHIÊN:

Phân tích giá trị suy biến (Singular Value Decomposition - SVD):
- Phân tích A = U × Σ × Vᵀ cho ma trận m×n bất kỳ
- U (m×m): Ma trận trực chuẩn các vector riêng trái
- Σ (m×n): Ma trận đường chéo chứa các giá trị suy biến (singular values)
- V (n×n): Ma trận trực chuẩn các vector riêng phải

Ý nghĩa:
- Phân tích bất kỳ phép biến đổi tuyến tính nào thành 3 bước:
  1. Xoay trong không gian nguồn (Vᵀ)
  2. Co giãn theo các trục (Σ)
  3. Xoay trong không gian đích (U)

Thuật toán SVD qua ma trận Gram (AᵀA):

Bước 1: Tính ma trận Gram AᵀA (n×n)
- Đây là ma trận đối xứng xác định nửa dương
- Trị riêng của AᵀA = bình phương các giá trị suy biến

Bước 2: Tính trị riêng và vector riêng của AᵀA
- λ₁ ≥ λ₂ ≥ ... ≥ λₙ ≥ 0 (trị riêng)
- v₁, v₂, ..., vₙ (vector riêng) → tạo thành V
- Sắp xếp giảm dần theo trị riêng

Bước 3: Tính các giá trị suy biến
- σᵢ = √λᵢ (căn bậc hai của trị riêng)
- Đặt trên đường chéo của Σ

Bước 4: Tính U từ A và V
- uᵢ = (A × vᵢ) / σᵢ (với σᵢ ≠ 0)
- Các uᵢ là vector riêng của AAᵀ

Bước 5: Hoàn thiện U (nếu m > n)
- Bổ sung các vector trực giao để đủ m chiều
- Sử dụng Gram-Schmidt

Đặc điểm:
- Luôn tồn tại với mọi ma trận
- σ₁ ≥ σ₂ ≥ ... ≥ σᵣ > 0 (r = rank của A)
- Hạng của A = số giá trị suy biến khác 0

Ứng dụng:
- Nén ảnh (chỉ giữ k giá trị lớn nhất)
- Khử nhiễu dữ liệu
- Giải hệ phương trình suy biến
- Hệ gợi ý (recommendation systems)
- Principal Component Analysis (PCA)


function jacobiEigenvalue(A):
    n = size(A)
    B = copy(A)
    V = identity_matrix(n, n)
    
    epsilon = 1e-10
    maxIter = 100
    
    for iter = 0 to maxIter:
        maxVal = 0
        p = 0
        q = 1
        
        for i = 0 to n-1:
            for j = i+1 to n-1:
                if |B[i][j]| > maxVal:
                    maxVal = |B[i][j]|
                    p = i
                    q = j
        
        if maxVal < epsilon:
            break
        
        theta = 0.5 * atan2(2 * B[p][q], B[p][p] - B[q][q])
        c = cos(theta)
        s = sin(theta)
        
        // Givens rotation
        for i = 0 to n-1:
            Bip = B[i][p]
            Biq = B[i][q]
            B[i][p] = c * Bip + s * Biq
            B[i][q] = -s * Bip + c * Biq
            B[p][i] = B[i][p]
            B[q][i] = B[i][q]
        
        Bpp = B[p][p]
        Bqq = B[q][q]
        Bpq = B[p][q]
        B[p][p] = c*c*Bpp + 2*c*s*Bpq + s*s*Bqq
        B[q][q] = s*s*Bpp - 2*c*s*Bpq + c*c*Bqq
        B[p][q] = B[q][p] = 0
        
        for i = 0 to n-1:
            Vip = V[i][p]
            Viq = V[i][q]
            V[i][p] = c * Vip + s * Viq
            V[i][q] = -s * Vip + c * Viq
    
    return (V, B)
