THUAT TOAN: Dinh ly Du Trung Hoa (Chinese Remainder Theorem)
DO PHUC TAP: O(n^2 * log(M)) voi M la tich cac moduli

PSEUDO CODE:
function extendedGCD(a, b):
    if b == 0:
        return (a, 1, 0)
    
    gcd, x1, y1 = extendedGCD(b, a % b)
    x = y1
    y = x1 - (a / b) * y1
    return (gcd, x, y)

function modularInverse(a, m):
    gcd, x, y = extendedGCD(a, m)
    if gcd != 1:
        return null  // Khong ton tai nghich dao
    return (x % m + m) % m

function chineseRemainder(remainders, moduli):
    // Giai he: x ≡ a_i (mod m_i)
    n = length(remainders)
    M = 1
    
    // Tinh tich cac moduli
    for i = 0 to n-1:
        M = M * moduli[i]
    
    x = 0
    for i = 0 to n-1:
        M_i = M / moduli[i]
        y_i = modularInverse(M_i, moduli[i])
        x = x + remainders[i] * M_i * y_i
    
    return x % M

MÔ TẢ BẰNG NGÔN NGỮ TỰ NHIÊN:

Thuật toán: Định lý Thặng dư Trung Hoa

Input:
• Mảng remainders: [a₁, a₂, ..., aₙ]
• Mảng moduli: [m₁, m₂, ..., mₙ]
• Điều kiện: gcd(mᵢ, mⱼ) = 1 ∀i≠j

Bài toán: Tìm x thỏa mãn:
• x ≡ a₁ (mod m₁)
• x ≡ a₂ (mod m₂)
• ...
• x ≡ aₙ (mod mₙ)

Khởi tạo:
• M = m₁ × m₂ × ... × mₙ
• x = 0

Lặp:
1. Với i từ 0 đến n-1:
   - Mᵢ = M / mᵢ
   - yᵢ = modularInverse(Mᵢ, mᵢ)
     * Tìm yᵢ sao cho: yᵢ × Mᵢ ≡ 1 (mod mᵢ)
     * Dùng thuật toán Euclid mở rộng
   - x = x + aᵢ × Mᵢ × yᵢ

2. Trả về: x mod M

Ví dụ:
• x ≡ 2 (mod 3)
• x ≡ 3 (mod 5)
• x ≡ 2 (mod 7)
• M = 105, nghiệm: x = 23
